================================================================================
 SONARQUBE FULL REFACTOR ASSESSMENT â€” All "Refactor" Issues
 Updated: 2025-02-21 (post-Batch 15, commit b8f9337)
 Scan total: 120 issues | Fixed: 15 (S1188 Batch 15) | Remaining: 105
 Skip candidates: ~34 | Actionable: ~71
================================================================================

LEGEND
â•â•â•â•â•â•
Difficulty:   â˜…â˜†â˜†â˜† EASY       â€” Simple extraction/rename, <30 min
              â˜…â˜…â˜†â˜† MODERATE   â€” Structural changes, 30-90 min, needs testing
              â˜…â˜…â˜…â˜† HARD       â€” Deep refactoring, 1-4 hours, risk of regression
              â˜…â˜…â˜…â˜… VERY HARD  â€” Architectural change, half-day+, high risk

Opportunity:  ğŸ”´ HIGH   â€” Major gain: testability, maintainability, reliability
              ğŸŸ¡ MEDIUM â€” Nice improvement, moderate real-world benefit
              ğŸŸ¢ LOW    â€” Cosmetic or minimal practical impact
              â›” SKIP   â€” False positive, framework constraint, counterproductive

Format: Line Function                          CC/Count  Difficulty  Opportunity


################################################################################
#  C++ ISSUES (86 entries)                                                     #
################################################################################

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 cpp:S3776 â€” Cognitive Complexity (limit: 25) â€” 19 issues
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Highest-value rule. Each function exceeds the CC threshold, meaning it has
too many branching paths to reason about safely. Splitting reduces bugs.

--- APIRoutes.cpp ---
 L244  setupAPIRoutes()                   CC=249 (25)  â˜…â˜…â˜…â˜†  âš ï¸ STALE
   âš ï¸ SCAN PREDATES BATCH 15. After lambda extraction (b8f9337), CC should
   have dropped dramatically (~60-80). Rescan will likely still show S3776
   but at a much lower CC. Remaining CC comes from inline route registrations,
   JSON parsing, and validation inside each server.on() call.
   â†’ NEXT STEP: Rescan. If CC still >25, extract validation logic from
     remaining inline lambdas into helper functions.
   OPPORTUNITY: ğŸŸ¡ MEDIUM â€” Most body was already extracted in Batch 15.
   Remaining work is incremental cleanup.

--- StepperController.cpp ---
 L363  motorTask()                        CC=34 (25)   â˜…â˜…â˜†â˜†  ğŸŸ¡ MEDIUM
   FreeRTOS task function. Main control loop with mode switch (idle/simple/
   oscillation/chaos/sequence/calibration) + emergency stop checks.
   â†’ Extract mode-specific blocks into processModeXxx() helpers.
   OPPORTUNITY: ğŸŸ¡ MEDIUM â€” Improves readability of the main loop.
   Not a frequent change-site, so moderate payoff.

--- CommandDispatcher.cpp (5 functions, all high-value) ---
 L126  handleBasicCommands()              CC=47 (25)   â˜…â˜…â˜…â˜†  ğŸ”´ HIGH
   Large switch-like dispatcher for basic commands (start/stop/speed/position
   /direction/accel/decel/pause). Each command arm does validation + action.
   â†’ Strategy pattern: command map â†’ handler functions, or extract each
     command arm into handleStartCmd(), handleSpeedCmd(), etc.
   OPPORTUNITY: ğŸ”´ HIGH â€” Most-modified file after feature additions.
   New commands always added here. Table-driven dispatch would make it
   trivially extensible and testable.

 L338  handleDecelZoneCommands()          CC=59 (25)   â˜…â˜…â˜…â˜†  ğŸ”´ HIGH
   Highest CC in CommandDispatcher. Handles zone-related commands with
   complex validation (zone size, effect type, intensity, speed limits).
   â†’ Extract per-zone-parameter handlers. Many validation blocks are
     structurally identical â€” templatizable.
   OPPORTUNITY: ğŸ”´ HIGH â€” CC=59 is the highest in the file. Zone logic
   is error-prone and growing. Breaking it down prevents zone-related bugs.

 L571  handleChaosCommands()              CC=32 (25)   â˜…â˜…â˜†â˜†  ğŸŸ¡ MEDIUM
   Chaos mode command dispatch. Moderate CC, similar pattern to above.
   â†’ Same strategy: command map or per-command helpers.
   OPPORTUNITY: ğŸŸ¡ MEDIUM â€” Less frequently modified than basic/zone.

 L670  handleOscillationCommands()        CC=42 (25)   â˜…â˜…â˜…â˜†  ğŸ”´ HIGH
   Oscillation parameter commands. Complex because oscillation has many
   parameters (amplitude, period, waveform, phase, modulation, etc.).
   â†’ Group related params, extract handlers per parameter group.
   OPPORTUNITY: ğŸ”´ HIGH â€” Oscillation is the most complex movement mode
   with the most user-facing parameters. Reducing CC here prevents
   subtle parameter interaction bugs.

 L798  handleSequencerCommands()          CC=49 (25)   â˜…â˜…â˜…â˜†  ğŸ”´ HIGH
   Sequencer command dispatch. Line editing, playlist control, mode changes.
   â†’ Per-command handler extraction (same pattern as others).
   OPPORTUNITY: ğŸ”´ HIGH â€” Sequencer is critical and complex.

 â¬†ï¸ BATCH OPPORTUNITY: All 5 CommandDispatcher functions follow the SAME
 pattern (dispatch + validate + act). A single refactoring approach
 (command table or handler map) would fix ALL 5 at once: CC reduction
 from ~229 total to ~60-80. Fixes 5 S3776 issues in one batch.

--- NetworkManager.cpp ---
 L444  checkConnectionHealth()            CC=42 (25)   â˜…â˜…â˜…â˜†  ğŸ”´ HIGH
   Connection monitoring: WiFi state machine + SNTP sync + ping logic +
   reconnection + AP fallback. Many interleaved conditions.
   â†’ Extract: checkWiFiState(), checkSntpSync(), tryReconnect(),
     fallbackToAP() â€” each is an independent concern.
   OPPORTUNITY: ğŸ”´ HIGH â€” Network reliability is critical on ESP32.
   This function is called periodically and handles ALL recovery logic.
   Splitting makes each recovery path independently testable and debuggable.

--- WiFiConfigManager.cpp ---
 L137  scanNetworks()                     CC=30 (25)   â˜…â˜…â˜†â˜†  ğŸŸ¡ MEDIUM
   WiFi scan with duplicate removal, signal strength sorting, hidden
   network filtering. Straightforward but branchy.
   â†’ Extract filterDuplicates() and sortBySignal() helpers.
   OPPORTUNITY: ğŸŸ¡ MEDIUM â€” Touched infrequently, works reliably.

--- FileSystem.cpp ---
 L23   mount()                            CC=39 (25)   â˜…â˜…â˜†â˜†  ğŸŸ¡ MEDIUM
   LittleFS mount with format-on-fail + partition validation + space logging.
   â†’ Extract validatePartition(), formatAndRetry() helpers.
   OPPORTUNITY: ğŸŸ¡ MEDIUM â€” Run-once at boot, rarely modified.

--- BaseMovementController.cpp (3 functions) ---
 L264  checkAndTriggerRandomTurnback()    CC=28 (25)   â˜…â˜…â˜†â˜†  ğŸŸ¡ MEDIUM
   Random reversal logic with zone awareness and probability calculation.
   â†’ Extract shouldTrigger() predicate + zone boundary check.
   OPPORTUNITY: ğŸŸ¡ MEDIUM â€” Barely over threshold (28/25).

 L698  process()                          CC=27 (25)   â˜…â˜…â˜†â˜†  ğŸŸ¡ MEDIUM
   Main movement processing loop. Mode dispatching + step timing.
   â†’ Extract mode handlers into separate methods.
   OPPORTUNITY: ğŸŸ¡ MEDIUM â€” Barely over threshold (27/25).

 L802  doStep()                           CC=34 (25)   â˜…â˜…â˜…â˜†  ğŸ”´ HIGH
   Core stepping function: direction logic + acceleration + deceleration
   zone handling + contact sensor checks + position tracking.
   â†’ Extract applyAcceleration(), checkDecelZone(), handleContactSensor().
   OPPORTUNITY: ğŸ”´ HIGH â€” This is the innermost hot loop. Every motor
   step passes through here. Clean separation of concerns aids debugging
   stepper issues (acceleration glitches, zone overshoot, etc.).

--- CalibrationManager.cpp (3 functions, all CASCADE) ---
 L77   findContact()                      CC=31 (25)   â˜…â˜…â˜…â˜†  ğŸ”´ HIGH
   Blocking function that moves until contact sensor triggers. Has
   WebSocket service calls interleaved (to keep UI responsive during
   long moves). Deep nesting from polling loops.
   â†’ Extract: moveUntilContact() core loop + wsServiceGuard() RAII wrapper.
   OPPORTUNITY: ğŸ”´ HIGH â€” Calibration accuracy depends on this.
   The WebSocket service calls add nesting that obscures the core logic.
   Refactoring makes the motion logic clear and the WS servicing automatic.

 L200  startCalibration()                 CC=57 (25)   â˜…â˜…â˜…â˜…  ğŸ”´ HIGH
   HIGHEST CC in movement code. Full calibration sequence: forward contact,
   measure distance, check error, retry if needed, reverse contact, compute
   range. Multiple retry loops with nested WebSocket service.
   â†’ Split into calibration phases: measureForward(), validateMeasurement(),
     measureReverse(), computeRange(). Each phase is independently testable.
   OPPORTUNITY: ğŸ”´ HIGH â€” Calibration is the most failure-prone operation.
   Users report occasional bad calibrations. Splitting into phases makes it
   possible to test and debug each phase independently. Very high value.

 L363  returnToStart()                    CC=44 (25)   â˜…â˜…â˜…â˜†  ğŸ”´ HIGH
   Post-calibration return movement. Polling loop with nested conditions
   for contact avoidance + WebSocket servicing.
   â†’ Same RAII-guard approach as findContact.
   OPPORTUNITY: ğŸ”´ HIGH â€” Cascades with findContact() and startCalibration().
   All 3 share the same nesting pattern (blocking loop + WS service).
   A shared utility pattern fixes all 3.

 â¬†ï¸ CASCADE: All 3 CalibrationManager S3776 + 9 S134 share the SAME root
 cause (blocking loops with interleaved WebSocket service). A single RAII
 WS service guard or coroutine-like approach fixes 12 issues at once.

--- ChaosController.cpp ---
 L729  process()                          CC=47 (25)   â˜…â˜…â˜…â˜†  ğŸ”´ HIGH
   Chaos mode main loop: state machine (setup â†’ running â†’ at_target â†’
   deciding_next) with pattern-specific branching.
   â†’ Extract per-state handlers: processSetup(), processRunning(),
     processAtTarget(), processDecision().
   OPPORTUNITY: ğŸ”´ HIGH â€” Chaos mode is the most complex movement mode
   with 11 different patterns. The state machine is hard to debug when
   patterns misbehave. Per-state extraction makes pattern issues traceable.

--- OscillationController.cpp ---
 L255  calculatePosition()                CC=52 (25)   â˜…â˜…â˜…â˜†  ğŸ”´ HIGH
   HIGHEST CC in a single-purpose function. Calculates oscillation position
   based on waveform type (sine/triangle/square/sawtooth) + modulation +
   boundary clamping + direction reversal. Deeply nested math branches.
   â†’ Extract per-waveform calculators: calcSine(), calcTriangle(), etc.
     Modulation is orthogonal â†’ separate applyModulation() helper.
   OPPORTUNITY: ğŸ”´ HIGH â€” This is pure math logic that's PERFECTLY suited
   for unit testing via extracting into pure functions. Each waveform
   should be independently testable. Very high refactoring value.

--- SequenceExecutor.cpp ---
 L642  process()                          CC=32 (25)   â˜…â˜…â˜†â˜†  ğŸŸ¡ MEDIUM
   Sequence execution state machine: similar to chaos process().
   â†’ Extract per-state handlers.
   OPPORTUNITY: ğŸŸ¡ MEDIUM â€” Simpler than chaos, less frequently modified.


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 cpp:S134 â€” Nesting Depth >3 â€” 12 issues
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Deep nesting makes code hard to read. Often fixed as a side effect of
S3776 refactoring (same root causes).

--- BaseMovementController.cpp (2 issues) ---
 L282  inside checkAndTriggerRandomTurnback()           â˜…â˜…â˜†â˜†  ğŸŸ¡ MEDIUM
 L286  inside checkAndTriggerRandomTurnback()           â˜…â˜…â˜†â˜†  ğŸŸ¡ MEDIUM
   Pending turnback check nested inside zone boundary check.
   â†’ Early return pattern: invert outer conditions, return early.
   OPPORTUNITY: ğŸŸ¡ MEDIUM â€” Automatically fixed if S3776 L264 is addressed.

--- CalibrationManager.cpp (9 issues â€” ALL cascade) ---
 L115  inside findContact()                             â˜…â˜…â˜…â˜†  ğŸ”´ HIGH
 L116  inside findContact()                             â˜…â˜…â˜…â˜†  ğŸ”´ HIGH
   WebSocket service call nested inside polling loop inside sensor check.
 L258  inside startCalibration()                        â˜…â˜…â˜…â˜†  ğŸ”´ HIGH
 L298  inside startCalibration()                        â˜…â˜…â˜…â˜†  ğŸ”´ HIGH
 L336  inside startCalibration()                        â˜…â˜…â˜…â˜†  ğŸ”´ HIGH
   Retry loops with nested validation and WS service.
 L383  inside returnToStart()                           â˜…â˜…â˜…â˜†  ğŸ”´ HIGH
 L384  inside returnToStart()                           â˜…â˜…â˜…â˜†  ğŸ”´ HIGH
 L412  inside returnToStart()                           â˜…â˜…â˜…â˜†  ğŸ”´ HIGH
 L413  inside returnToStart()                           â˜…â˜…â˜…â˜†  ğŸ”´ HIGH
   Contact avoidance loops with interleaved WS service.

 â¬†ï¸ ALL 9 share the SAME root cause: blocking loops + WebSocket service
 nesting. The RAII WS service guard proposed for S3776 CalibrationManager
 would automatically eliminate all 9 nesting violations.
 OPPORTUNITY: ğŸ”´ HIGH â€” 9 issues fixed by one structural pattern.

--- SequenceExecutor.cpp ---
 L333  inside blockingMoveToStep()                      â˜…â˜…â˜†â˜†  ğŸŸ¡ MEDIUM
   WebSocket service inside blocking movement loop (same pattern as
   CalibrationManager). Same RAII guard applies here too.
   OPPORTUNITY: ğŸŸ¡ MEDIUM â€” Single instance, less impactful alone.


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 cpp:S1188 â€” Lambda Too Long (limit: 20 lines) â€” 15 issues
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  âœ… ALL FIXED â€” Batch 15 (commit b8f9337)
  All 15 oversized lambdas in APIRoutes.cpp::setupAPIRoutes() were
  extracted into named static void handleXxx() functions.

  âš ï¸ NOTE: This scan PREDATES Batch 15 (line numbers reference the
  pre-extraction code layout). A rescan will confirm these are resolved.

 L303, L336, L378, L426, L505, L559, L670, L714, L803, L890,
 L932, L984, L1035, L1081, L1278
 â†’ All extracted to: handleGetStats, handleGetCalibrationState,
   handlePostCalibrate, handlePostCalibrateAction, handleGetSequencer,
   handlePutSequencer, handlePostSequencerControl, handlePostSequencerAction,
   handleGetLogs, handleDeleteLogs, handleGetSystemDiagnostics,
   handlePostReboot, handlePostFactoryReset, handlePostFirmwareUpload,
   handleGetFilesystem.


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 cpp:S1820 â€” Too Many Fields (limit: 20) â€” 3 issues
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
SonarQube wants max 20 fields per struct. All 3 structs in Types.h
are data-carrying value types (not classes with behavior).

--- Types.h ---
 L290  OscillationState                   23 fields     â˜…â˜…â˜…â˜†  ğŸŸ¡ MEDIUM
   Oscillation runtime state: position, direction, timing, modulation,
   boundary tracking, transition state, waveform parameters.
   Fields group into: core (pos/dir/timing), modulation (3-4 fields),
   transition (4-5 fields), boundaries (3-4 fields).
   â†’ Could nest: OscModulation, OscTransition, OscBoundaries sub-structs.
   OPPORTUNITY: ğŸŸ¡ MEDIUM â€” Would improve readability of oscillation code
   but requires updating all access sites (state.transition.phase instead
   of state.transitionPhase). Moderate churn for moderate gain.

 L354  ChaosExecutionState                24 fields     â˜…â˜…â˜…â˜†  ğŸŸ¢ LOW
   Chaos pattern runtime state: current pattern, step tracking, phase
   info, timing, speed tracking, repeat counts. Many fields are
   union-like (only used by specific patterns).
   â†’ Sub-structs by pattern family, or use std::variant per pattern.
   OPPORTUNITY: ğŸŸ¢ LOW â€” This struct is inherently complex because chaos
   patterns are diverse. Splitting would add access verbosity without
   improving the inherent complexity. The variant approach adds overhead
   inappropriate for ESP32 hot-path.

 L403  SequenceLine                       27 fields     â˜…â˜…â˜…â˜†  ğŸŸ¡ MEDIUM
   Sequence line definition: target position, speed, timing, oscillation
   params, chaos params, mode settings. Multi-mode flat struct.
   â†’ Could group: SequenceLineBase (pos/speed/timing), OscParams, ChaosParams.
   OPPORTUNITY: ğŸŸ¡ MEDIUM â€” 27 fields IS a lot. Grouping by movement mode
   would make the JSON serialization clearer and reduce the risk of
   accidentally setting chaos params in oscillation mode. Moderate value.


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 cpp:S1448 â€” Too Many Methods (limit: 35) â€” 2 issues
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

--- UtilityEngine.h ---
 L82   UtilityEngine                      43 methods    â˜…â˜†â˜†â˜†  â›” SKIP
   FACADE PATTERN â€” All 43 methods are one-line inline forwarders:
     String getFormattedTime() { return _logger.getFormattedTime(); }
     void saveStats() { _stats.saveStats(); }
   Delegates to 4 subsystems: _logger, _fs, _stats, _eeprom.
   SonarQube doesn't understand facades. Splitting this class would
   REMOVE the facade benefit (single access point for utility services).
   â†’ RECOMMENDATION: â›” SKIP. Add to SonarLint exclusions for this file,
   or add // NOSONAR comment on the class declaration.
   OPPORTUNITY: â›” SKIP â€” Splitting would be counterproductive.

--- ChaosController.h ---
 L45   ChaosController                    41 methods    â˜…â˜…â˜…â˜†  ğŸŸ¡ MEDIUM
   11 pattern handlers (handleLinear, handleZigzag, handleSpiral, etc.)
   + 6 at-target handlers + 8 helper methods + public API.
   All methods are cohesive (all operate on chaos state).
   â†’ Could extract a ChaosPatternStrategy per pattern family, but this
     adds vtable overhead in a hot path.
   OPPORTUNITY: ğŸŸ¡ MEDIUM â€” The class IS large but cohesive. Extracting
   pattern handlers into a strategy pattern would improve modularity at
   the cost of indirection. Worth considering if more patterns are added.


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 cpp:S6018 â€” Use Inline Variables â€” 10 issues
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
SonarQube wants C++17 `inline static` member variables instead of
Meyer's Singleton pattern (static local in getInstance()).

  â›” ALL 10: SKIP â€” Meyer's Singleton is INTENTIONAL for ESP32

  Reason: Meyer's Singleton (`static Foo& getInstance() { static Foo inst; ... }`)
  guarantees lazy initialization and thread-safe construction (C++11+).
  Switching to `inline static Foo instance;` would:
  1. Change initialization ORDER â€” instance created at static init time
     instead of first use. On ESP32, hardware peripherals may not be ready
     at static init time (before setup() runs).
  2. REMOVE lazy initialization â€” all singletons constructed at boot,
     increasing boot time and memory usage even if never used.
  3. Break the init dependency chain â€” singletons currently init in the
     order they're first accessed, which matches the dependency graph.

  Affected singletons (all follow identical pattern):
  L40   SequenceTableManager.h  getInstance()   â›” SKIP
  L28   CommandDispatcher.cpp   getInstance()   â›” SKIP
  L25   NetworkManager.cpp      getInstance()   â›” SKIP
  L28   StatusBroadcaster.cpp   getInstance()   â›” SKIP
  L38   WiFiConfigManager.cpp   getInstance()   â›” SKIP
  L21   ContactSensors.cpp      getInstance()   â›” SKIP
  L23   MotorDriver.cpp         getInstance()   â›” SKIP
  L23   CalibrationManager.cpp  getInstance()   â›” SKIP
  L33   ChaosController.cpp     getInstance()   â›” SKIP
  L38   SequenceExecutor.cpp    getInstance()   â›” SKIP

  â†’ RECOMMENDATION: Disable cpp:S6018 in SonarLint workspace settings
    or add // NOSONAR to each getInstance() method.


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 cpp:S6229 â€” Replace time()/strftime() with std::chrono â€” 20 issues
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
SonarQube wants modern C++ <chrono> instead of C-style time functions.
On ESP32, time() reads from SNTP-synchronized RTC. std::chrono::system_clock
reads from the same source but adds abstraction.

  ALL 20: â˜…â˜…â˜†â˜† MODERATE difficulty, ğŸŸ¡ MEDIUM opportunity

  The change is safe but requires creating a shared time utility:
  â†’ Create TimeUtils::now() and TimeUtils::formatTime() wrappers that
    use std::chrono internally and replace all 20 call sites.

  Risk: std::chrono::format() (C++20) may not be fully supported on
  ESP32 GCC 14.2.0 toolchain. May need to keep strftime() internally.

  Grouped by file:
  APIRoutes.cpp       (1)  L652  â€” time() in handleGetStats response
  NetworkManager.cpp  (3)  L312,L317  â€” setupNTP time check
                           L659       â€” syncTimeFromClient formatting
  CrashDiagnostics.cpp(2)  L139,L144  â€” saveDumpFile timestamp filename
  UtilityEngine.cpp   (3)  L111,L115  â€” getFormattedTime()
                           L120       â€” isTimeSynchronized()
  Logger.cpp          (7)  L76,L79    â€” initializeLogFile header
                           L207,L219  â€” flushLogBuffer timestamps
                           L249,L254  â€” generateLogFilename
                           L288       â€” isTimeSynchronized check
  StatsManager.cpp    (4)  L109,L117  â€” incrementDailyStats
                           L156,L160  â€” getTodayDistance

  OPPORTUNITY: ğŸŸ¡ MEDIUM â€” All 20 instances are the same pattern. A single
  TimeUtils wrapper class fixes all at once. Pure mechanical replacement,
  no logic changes. Good "code hygiene" but no behavioral benefit.

  BATCH STRATEGY: Create TimeUtils.h/.cpp â†’ replace all 20 call sites
  in one batch. ~2 hours, low risk, eliminates 20 issues.


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 cpp:S5008 â€” Replace void* â€” 3 issues
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  â›” ALL 3: SKIP â€” FreeRTOS API REQUIREMENT

  FreeRTOS xTaskCreatePinnedToCore() REQUIRES a `void*` parameter for
  the task function signature. This is a C API â€” cannot be changed.

  L363  StepperController.cpp  motorTask(void*)     â›” SKIP
  L484  StepperController.cpp  networkTask(void*)   â›” SKIP
  L425  NetworkManager.cpp     ping callback void*  â›” SKIP

  â†’ RECOMMENDATION: Disable cpp:S5008 in SonarLint workspace settings
    for .cpp files, or add // NOSONAR to the 3 function signatures.


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 cpp:S5205 â€” Replace Function Pointer with std::function â€” 3 issues
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

--- CalibrationManager.cpp ---
 L463  setStatusCallback(void(*)(const char*))         â˜…â˜…â˜†â˜†  ğŸŸ¡ MEDIUM
 L467  setErrorCallback(void(*)(const char*, const char*))  â˜…â˜…â˜†â˜†  ğŸŸ¡ MEDIUM
 L471  setCompletionCallback(void(*)(bool))            â˜…â˜…â˜†â˜†  ğŸŸ¡ MEDIUM

   Raw function pointers used for calibration status/error/completion
   callbacks. SonarQube wants std::function or templates.
   â†’ std::function<void(const char*)> etc. â€” BUT std::function causes
     heap allocation on ESP32, which is undesirable in motor control code.
   â†’ Template approach: template<typename F> void setStatusCallback(F&& f)
     â€” avoids heap allocation but makes CalibrationManager a template,
     complicating the header.
   â†’ Best approach: Keep raw function pointers but typedef them:
       using StatusCallback = void(*)(const char*);
       void setStatusCallback(StatusCallback cb);
     This doesn't fix S5205 but improves readability.

   OPPORTUNITY: ğŸŸ¡ MEDIUM â€” std::function would be cleaner but adds heap
   allocation risk. Template approach is cleanest but most invasive.
   Function pointer typedef is practical but doesn't satisfy SonarQube.
   Weigh heap safety vs. code style.


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 cpp:S107 â€” Too Many Parameters (limit: 7) â€” 2 issues
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

--- ChaosController.cpp ---
 L398  handleMultiPhase(8 params)                      â˜…â˜…â˜†â˜†  ğŸŸ¡ MEDIUM
   Parameters: state, pattern-specific config (speed ranges, step counts,
   timing values). All are chaos pattern configuration.
   â†’ Group into a ChaosPhaseConfig struct.

 L646  handleMultiPhaseAtTarget(9 params)              â˜…â˜…â˜†â˜†  ğŸŸ¡ MEDIUM
   Same pattern as above, for at-target behavior.
   â†’ Same ChaosPhaseConfig struct, possibly extended.

   OPPORTUNITY: ğŸŸ¡ MEDIUM â€” These are internal helper functions called
   from a few places. Struct grouping is clean and a good practice, but
   the callers already pass structured data from ChaosPatterns.h.
   The real question is whether ChaosPatterns.h already has a suitable
   struct that could be passed directly.


################################################################################
#  JAVASCRIPT ISSUES (26 entries)                                              #
################################################################################

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 javascript:S3776 â€” Cognitive Complexity (limit: 15) â€” 24 issues
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

--- controllers/SimpleController.js ---
 L487  updateZoneEffectUI()               CC=87 (15)   â˜…â˜…â˜…â˜…  ğŸ”´ HIGH
   ğŸ† HIGHEST CC IN ENTIRE JS CODEBASE. Manages zone effect UI: show/hide
   controls based on effect type + slider ranges + linked checkbox state
   + preview canvas + tooltip updates. Massive branching on effect type.
   â†’ Extract per-effect-type UI handler: updateLinearZoneUI(),
     updateExpZoneUI(), etc. Each effect type's UI logic is independent.
   OPPORTUNITY: ğŸ”´ HIGH â€” This function is the primary maintainability
   bottleneck in the UI. Every new zone effect requires modifying this
   monster. Per-effect extraction makes adding new effects trivial.

--- controllers/OscillationController.js ---
 L213  updateOscillationUI()              CC=47 (15)   â˜…â˜…â˜…â˜†  ğŸ”´ HIGH
   Oscillation UI state management: enable/disable controls based on
   mode + waveform + modulation + boundary settings.
   â†’ Extract per-section updaters: updateWaveformControls(),
     updateModulationControls(), updateBoundaryControls().
   OPPORTUNITY: ğŸ”´ HIGH â€” Same pattern as SimpleController. Complex UI
   state logic that should be decomposed by concern.

--- controllers/PlaylistController.js ---
 L505  loadSimplePreset()                 CC=58 (15)   â˜…â˜…â˜…â˜†  ğŸ”´ HIGH
   Creates a full preset from current simple mode settings. Collects
   data from many UI fields + validates + transforms.
   â†’ Extract: collectSimpleFields(), validatePreset(), transformPreset().
   OPPORTUNITY: ğŸ”´ HIGH â€” Long function with many field accesses.
   Splitting improves testability of preset logic.

 L680  loadOscCyclePausePreset()          CC=24 (15)   â˜…â˜…â˜†â˜†  ğŸŸ¡ MEDIUM
   Similar pattern for oscillation presets but smaller.
   â†’ Same approach: collect + validate + transform.
   OPPORTUNITY: ğŸŸ¡ MEDIUM â€” Manageable CC (24), lower priority.

 L877  quickAddToSequencer()              CC=31 (15)   â˜…â˜…â˜†â˜†  ğŸŸ¡ MEDIUM
   Validate sequence line + send to backend.
   â†’ Extract validation into a pure function (reusable).
   OPPORTUNITY: ğŸŸ¡ MEDIUM â€” Moderate complexity, moderate payoff.

--- controllers/SequenceController.js ---
 L358  editSequenceLine()                 CC=17 (15)   â˜…â˜†â˜†â˜†  ğŸŸ¢ LOW
   Only 2 over threshold. Minor branching complexity.
   â†’ Small extraction would fix.
   OPPORTUNITY: ğŸŸ¢ LOW â€” Barely over threshold, low priority.

 L549  validateEditForm()                 CC=44 (15)   â˜…â˜…â˜…â˜†  ğŸ”´ HIGH
   Sequence line edit form validation. Many field-level validations
   with mode-specific rules.
   â†’ Extract per-field validators: validateSpeed(), validatePosition(),
     validateOscParams(), validateChaosParams().
   OPPORTUNITY: ğŸ”´ HIGH â€” Validation logic should be pure and testable.
   Currently tangled with DOM access. Separating validation from DOM
   enables pure function testing.

 L885  updateSequenceButtons()            CC=24 (15)   â˜…â˜…â˜†â˜†  ğŸŸ¡ MEDIUM
   Button state management based on sequence state.
   â†’ State table approach or per-state button configs.
   OPPORTUNITY: ğŸŸ¡ MEDIUM â€” UI state logic, moderate complexity.

--- controllers/ChaosController.js ---
 L145  updateChaosUI()                    CC=17 (15)   â˜…â˜†â˜†â˜†  ğŸŸ¢ LOW
   Barely over threshold. Minor UI state adjustments.
   OPPORTUNITY: ğŸŸ¢ LOW â€” Near-threshold, not worth immediate attention.

--- main.js (4 functions) ---
 L18   updateSpeedDisplay()               CC=33 (15)   â˜…â˜…â˜†â˜†  ğŸŸ¡ MEDIUM
   Speed display formatting with unit conversion and milestone checks.
   â†’ Extract unit conversion + milestone logic.
   OPPORTUNITY: ğŸŸ¡ MEDIUM â€” Frequently called but stable logic.

 L151  syncInputsFromBackend()            CC=47 (15)   â˜…â˜…â˜…â˜†  ğŸ”´ HIGH
   Syncs ALL UI inputs from backend state. Massive field-by-field sync.
   â†’ Group by section: syncSpeedInputs(), syncOscInputs(), etc.
   OPPORTUNITY: ğŸ”´ HIGH â€” This is the primary UI synchronization point.
   Every new control added requires modifying this function. Per-section
   extraction makes the sync logic composable and maintainable.

 L205  updateControlsState()              CC=21 (15)   â˜…â˜…â˜†â˜†  ğŸŸ¡ MEDIUM
   Enable/disable controls based on movement mode.
   â†’ Mode-specific control state maps.
   OPPORTUNITY: ğŸŸ¡ MEDIUM â€” Moderate CC, touched occasionally.

 L273  updateUI()                         CC=75 (15)   â˜…â˜…â˜…â˜…  ğŸ”´ HIGH
   ğŸ† SECOND HIGHEST JS CC. Main UI update function called on every
   WebSocket message. Dispatches to all sub-updaters + handles state
   transitions + applies visual effects.
   â†’ This is already a composed function but still has too much inline
     logic. Extract state transition handling and visual effects.
   OPPORTUNITY: ğŸ”´ HIGH â€” Core UI update path. Called on every WS message.
   Keeping this clean is critical for UI responsiveness and correctness.

--- ui/StatsController.js ---
 L576  buildMilestoneTooltip()            CC=23 (15)   â˜…â˜…â˜†â˜†  ğŸŸ¡ MEDIUM
   Builds HTML tooltip for milestones with conditional sections.
   â†’ Extract per-section builders.
   OPPORTUNITY: ğŸŸ¡ MEDIUM â€” Display-only logic, moderate complexity.

--- ui/ToolsController.js ---
 L643  updateSystemStats()                CC=46 (15)   â˜…â˜…â˜…â˜†  ğŸ”´ HIGH
   System status display: memory, WiFi, uptime, firmware info. Many
   conditional formatting and threshold checks.
   â†’ Per-metric renderers: renderMemoryStats(), renderWiFiStats(), etc.
   OPPORTUNITY: ğŸ”´ HIGH â€” Frequently updated, grows with new metrics.
   Per-metric extraction makes it trivially extensible.

--- ui/UIController.js ---
 L26   switchTab()                        CC=22 (15)   â˜…â˜…â˜†â˜†  ğŸŸ¡ MEDIUM
   Tab switching with state persistence and lazy loading.
   â†’ Extract tab-specific init into a tab handler map.
   OPPORTUNITY: ğŸŸ¡ MEDIUM â€” Moderate complexity, moderate payoff.

--- utils/PlaylistUtils.js ---
 L62   zoneEffectPresetTooltip()          CC=19 (15)   â˜…â˜†â˜†â˜†  ğŸŸ¢ LOW
   Tooltip text generation per effect type. Simple switch.
   â†’ Already a simple dispatch, barely over threshold.
   OPPORTUNITY: ğŸŸ¢ LOW â€” Near-threshold, minimal gain from refactoring.

 L119  presetTooltip()                    CC=21 (15)   â˜…â˜†â˜†â˜†  ğŸŸ¡ MEDIUM
   Dispatches tooltip generation by preset mode.
   â†’ Extract per-mode tooltip builders.
   OPPORTUNITY: ğŸŸ¡ MEDIUM â€” Small function, dispatch pattern.

--- utils/SequenceUtils.js ---
 L386  validateSequencerLinePure()         CC=78 (15)   â˜…â˜…â˜…â˜…  ğŸ”´ HIGH
   ğŸ† THIRD HIGHEST JS CC. Pure validation function for sequence lines.
   Multi-field validation with mode-specific rules and cross-field deps.
   â†’ Already "pure" (no DOM). Split into per-field validators and
     a cross-field constraint checker.
   OPPORTUNITY: ğŸ”´ HIGH â€” Already a pure function = PERFECT candidate
   for splitting. Each sub-validator becomes independently unit-testable.
   This is the ideal refactoring target.

 L553  getAllInvalidFieldsPure()           CC=51 (15)   â˜…â˜…â˜…â˜†  ğŸ”´ HIGH
   Collects all invalid fields for a sequence line. Related to above.
   â†’ Same decomposition: per-field validity checks.
   OPPORTUNITY: ğŸ”´ HIGH â€” Pure function, highly decomposable.

--- utils/SimpleUtils.js ---
 L98   drawZoneEffectPreviewPure()        CC=55 (15)   â˜…â˜…â˜…â˜†  ğŸ”´ HIGH
   Canvas drawing for zone effect preview. Per-effect-type rendering
   with coordinate math.
   â†’ Per-effect-type draw functions: drawLinearEffect(), drawExpEffect().
   OPPORTUNITY: ğŸ”´ HIGH â€” Pure canvas drawing, perfectly decomposable.
   Each effect's visual is independent. Extraction enables visual testing.

--- utils/utils.js ---
 L270  updateLinkedCheckboxState()        CC=18 (15)   â˜…â˜†â˜†â˜†  ğŸŸ¢ LOW
   Linked checkbox disabled state logic. Near threshold.
   OPPORTUNITY: ğŸŸ¢ LOW â€” Near-threshold, utility function.

 L367  syncPauseControlsToBackend()       CC=19 (15)   â˜…â˜†â˜†â˜†  ğŸŸ¢ LOW
   Pause control sync. Near threshold.
   OPPORTUNITY: ğŸŸ¢ LOW â€” Almost at threshold, minimal gain.

 L689  isRetryableError()                 CC=21 (15)   â˜…â˜†â˜†â˜†  ğŸŸ¢ LOW
   Error classification for retry logic. Simple conditions.
   OPPORTUNITY: ğŸŸ¢ LOW â€” Simple classifier, near threshold.


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 javascript:S3800 â€” Return Same Type â€” 1 issue
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

--- ui/StatsController.js ---
 L30   getDayNames()                                   â˜…â˜†â˜†â˜†  ğŸŸ¢ LOW
   Returns localized day name array. May return undefined/null in some
   edge case (missing locale data).
   â†’ Add explicit empty array fallback: return dayNames || [];
   OPPORTUNITY: ğŸŸ¢ LOW â€” Simple fix, defensive coding.


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 javascript:S7785 â€” Top-Level Await â€” 1 issue
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

--- main.js ---
 L519  boot() async IIFE                               â˜…â˜†â˜†â˜†  â›” SKIP
   `(async function boot() { ... })();` â€” SonarQube wants top-level await.
   This requires ES modules (`<script type="module">`), which would change
   the script loading model for the entire ESP32 web interface.
   â†’ SKIP: The async IIFE pattern is intentional and standard for
     classic script loading. Converting to ES modules is a large change
     with no behavioral benefit for an embedded web UI.
   OPPORTUNITY: â›” SKIP â€” Framework constraint. ESP32 serves classic
   scripts, not ES modules.


################################################################################
#  PYTHON ISSUES (5 entries)                                                   #
################################################################################

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 python:S3776 â€” Cognitive Complexity (limit: 15) â€” 5 issues
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
All Python files are DEVELOPMENT TOOLS, not production code.
They run on the developer's machine, not on the ESP32.

 L275  analyze_sonarqube.py  (?)          CC=21 (15)   â˜…â˜†â˜†â˜†  ğŸŸ¢ LOW
 L110  find_dead_code.py  parse()         CC=18 (15)   â˜…â˜†â˜†â˜†  ğŸŸ¢ LOW
 L181  find_dead_code.py  analyze()       CC=47 (15)   â˜…â˜…â˜†â˜†  ğŸŸ¢ LOW
 L249  find_dead_code.py  main()          CC=71 (15)   â˜…â˜…â˜†â˜†  ğŸŸ¢ LOW
 L483  upload_html.py     main()          CC=42 (15)   â˜…â˜…â˜†â˜†  ğŸŸ¢ LOW

 OPPORTUNITY: ALL ğŸŸ¢ LOW â€” These are dev scripts, not production code.
 Refactoring has zero impact on the deployed firmware. Fix only if the
 scripts themselves become hard to maintain.


################################################################################
#  SUMMARY TABLES                                                              #
################################################################################

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ISSUE COUNT BY OPPORTUNITY VALUE                                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Opportunity          â”‚ Count â”‚ Notes                                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ğŸ”´ HIGH              â”‚  ~32  â”‚ Most impactful refactorings            â”‚
â”‚ ğŸŸ¡ MEDIUM            â”‚  ~38  â”‚ Nice improvements                     â”‚
â”‚ ğŸŸ¢ LOW               â”‚  ~16  â”‚ Cosmetic / near-threshold             â”‚
â”‚ â›” SKIP               â”‚  ~15  â”‚ False positives / framework limits     â”‚
â”‚ âœ… FIXED (Batch 15)   â”‚  ~15  â”‚ S1188 lambda extraction               â”‚
â”‚ âš ï¸ STALE (pre-B15)    â”‚   ~1  â”‚ APIRoutes CC needs rescan             â”‚
â”‚ (S6229 batch â€” ğŸŸ¡)   â”‚  ~20  â”‚ All same pattern, one-batch fix       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ TOTAL                â”‚  120  â”‚                                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ SKIP CANDIDATES â€” 15 issues (recommend disable/NOSONAR)            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Rule                 â”‚ Count â”‚ Reason                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ cpp:S6018            â”‚  10   â”‚ Meyer's Singleton, ESP32 init order   â”‚
â”‚ cpp:S5008            â”‚   3   â”‚ FreeRTOS void* API requirement        â”‚
â”‚ cpp:S1448 (Utility)  â”‚   1   â”‚ Facade pattern by design              â”‚
â”‚ javascript:S7785     â”‚   1   â”‚ Classic scripts, not ES modules       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ TOTAL SKIPPABLE      â”‚  15   â”‚ â†’  Issue count drops to 90 remaining  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


################################################################################
#  PRIORITIZED REFACTORING ROADMAP                                             #
################################################################################

Priority based on: (Opportunity Ã— Issues_Fixed_Per_Effort) Ã· Risk

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
 PRIORITY 1 â€” CommandDispatcher (5 Ã— S3776)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
 Opportunity: ğŸ”´ HIGH | Difficulty: â˜…â˜…â˜…â˜† | Issues fixed: 5
 Approach: Command handler map/table for all 5 dispatch functions.
 One architectural pattern fixes the highest single-file issue count.
 Total CC reduction: ~229 â†’ ~60-80. Risk: MEDIUM (needs full test pass).

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
 PRIORITY 2 â€” CalibrationManager (3 Ã— S3776 + 9 Ã— S134 = 12 issues)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
 Opportunity: ğŸ”´ HIGH | Difficulty: â˜…â˜…â˜…â˜† | Issues fixed: 12
 Approach: RAII WebSocket service guard + phase extraction.
 HIGHEST issue-per-effort ratio: 12 issues from one structural pattern.
 Risk: HIGH (calibration is safety-critical, needs physical testing).

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
 PRIORITY 3 â€” OscillationController::calculatePosition (S3776 CC=52)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
 Opportunity: ğŸ”´ HIGH | Difficulty: â˜…â˜…â˜…â˜† | Issues fixed: 1
 Approach: Per-waveform pure function extraction.
 Perfect for unit testing â€” pure math with no side effects.
 Risk: LOW (pure functions, easily verified by tests).

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
 PRIORITY 4 â€” ChaosController::process (S3776 CC=47)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
 Opportunity: ğŸ”´ HIGH | Difficulty: â˜…â˜…â˜…â˜† | Issues fixed: 1
 Approach: Per-state handler extraction from state machine.
 Risk: MEDIUM (state transitions must be preserved exactly).

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
 PRIORITY 5 â€” S6229 std::chrono batch (20 issues)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
 Opportunity: ğŸŸ¡ MEDIUM | Difficulty: â˜…â˜…â˜†â˜† | Issues fixed: 20
 Approach: Create TimeUtils wrapper, replace all 20 call sites.
 HIGHEST raw issue count: 20 issues from mechanical replacement.
 Risk: LOW (behavioral equivalent, just wrapping existing calls).

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
 PRIORITY 6 â€” JS S3776 HIGH targets (updateZoneEffectUI, updateUI,
              validateSequencerLinePure, syncInputsFromBackend)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
 Opportunity: ğŸ”´ HIGH | Difficulty: â˜…â˜…â˜…â˜†-â˜…â˜…â˜…â˜… | Issues fixed: 8-10
 Approach: Per-function decomposition (see individual entries above).
 These are the ğŸ”´ HIGH JS functions. Each is independently tackable.
 Risk: MEDIUM (UI testing needed, no automated JS tests).

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
 PRIORITY 7 â€” NetworkManager::checkConnectionHealth (S3776 CC=42)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
 Opportunity: ğŸ”´ HIGH | Difficulty: â˜…â˜…â˜…â˜† | Issues fixed: 1
 Approach: Per-concern extraction (WiFi/SNTP/reconnect/fallback).
 Risk: HIGH (network reliability is critical, hard to test).

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
 PRIORITY 8 â€” BaseMovementController::doStep (S3776 CC=34)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
 Opportunity: ğŸ”´ HIGH | Difficulty: â˜…â˜…â˜…â˜† | Issues fixed: 1 (+2 S134)
 Approach: Extract accel/decel/contact helpers.
 Risk: HIGH (innermost hot loop, timing-sensitive).

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
 PRIORITY 9 â€” Remaining ğŸŸ¡ MEDIUM C++ S3776 (6 issues)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
 WiFiConfigManager CC=30, FileSystem CC=39, StepperController CC=34,
 BaseMovement CC=28, BaseMovement CC=27, SequenceExecutor CC=32.
 All moderate CC, moderate opportunity. Fix when touching these files.

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
 PRIORITY 10 â€” SKIP CANDIDATES (15 issues)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
 Add to SonarLint exclusions:
   cpp:S6018  (10 singletons â€” Meyer's pattern, ESP32 init order)
   cpp:S5008  (3 void* â€” FreeRTOS API mandate)
   cpp:S1448  (1 UtilityEngine â€” facade by design)
   javascript:S7785  (1 â€” classic scripts, not ES modules)
 â†’ Instantly reduces visible issue count by 15.


################################################################################
#  BEST "COMPLEX BUT INTERESTING" REFACTORINGS                                 #
################################################################################

These are HARD refactorings that deliver outsized value despite complexity:

1. ğŸ† CalibrationManager RAII WS Guard (â˜…â˜…â˜…â˜†, fixes 12 issues)
   One pattern â†’ 3 S3776 + 9 S134 gone. Transforms the most failure-prone
   code (calibration) from deeply-nested polling into clean phase-based
   logic. This is the single highest-ROI refactoring in the codebase.

2. ğŸ† CommandDispatcher Command Table (â˜…â˜…â˜…â˜†, fixes 5 issues)
   CC drops from ~229 to ~60-80. Makes adding new commands trivial.
   The dispatch pattern is identical across all 5 functions â€” one
   architectural decision propagates everywhere.

3. ğŸ† OscillationController::calculatePosition (â˜…â˜…â˜…â˜†, fixes 1 issue)
   Pure math decomposition. Each waveform becomes a pure function that
   can be PERFECTLY unit tested. The kind of refactoring that catches
   math bugs before they reach hardware.

4. ğŸ† JS validateSequencerLinePure + getAllInvalidFieldsPure (â˜…â˜…â˜…â˜…, fixes 2)
   ALREADY pure functions (no DOM!) â€” just need decomposition. These are
   the ideal "split into sub-validators" candidates. Would enable
   comprehensive validation testing without any UI infrastructure.

5. ğŸ† S6229 TimeUtils Wrapper (â˜…â˜…â˜†â˜†, fixes 20 issues)
   The easiest batch fix: one utility class, 20 mechanical call site
   replacements. Highest issue-count-per-effort ratio.

================================================================================
 END OF ASSESSMENT
================================================================================
